import 'package:fpdart/fpdart.dart';
import 'package:phrasly_ai_tools/src/core/network/models/app_error.dart';

import '../models/text_analysis_model.dart';
import 'writer_repo.dart';

class MockWriterRepo implements WriterRepo {
  @override
  Future<Either<AppError, TextAnalysisResult>> analyzeText(String text) async {
    // Simulate API delay
    await Future.delayed(const Duration(seconds: 2));

    // Mock AI detection logic - simple heuristic based on text patterns
    final aiPatterns = [
      'artificial intelligence',
      'machine learning',
      'neural network',
      'algorithm',
      'data processing',
      'predictive model',
      'automation',
      'generated by',
      'synthetic',
      'computational',
    ];

    final humanPatterns = [
      'I think',
      'I feel',
      'personally',
      'my experience',
      'I believe',
      'in my opinion',
      'from what I understand',
      'based on my knowledge',
    ];

    int aiScore = 0;
    int humanScore = 0;

    final lowerText = text.toLowerCase();

    for (final pattern in aiPatterns) {
      if (lowerText.contains(pattern)) {
        aiScore += 10;
      }
    }

    for (final pattern in humanPatterns) {
      if (lowerText.contains(pattern)) {
        humanScore += 15;
      }
    }

    // Add some randomness
    aiScore += (DateTime.now().millisecond % 30);
    humanScore += (DateTime.now().second % 25);

    final total = aiScore + humanScore;
    final aiProbability = total > 0 ? aiScore / total : 0.5;
    final humanProbability = 1.0 - aiProbability;

    TextSource source;
    if (aiProbability > 0.6) {
      source = TextSource.ai;
    } else if (humanProbability > 0.6) {
      source = TextSource.human;
    } else {
      source = TextSource.mixed;
    }

    final suggestions = <String>[];
    if (source == TextSource.ai) {
      suggestions.addAll([
        'Consider adding more personal experiences',
        'Use more conversational language',
        'Add emotional expressions',
        'Include personal opinions and beliefs',
      ]);
    } else if (source == TextSource.human) {
      suggestions.addAll([
        'Text appears human-like',
        'Good balance of personal and factual content',
        'Natural language flow detected',
      ]);
    }

    // Analyze sentences for detailed breakdown
    final sentences = text.split(RegExp(r'[.!?]+')).where((s) => s.trim().isNotEmpty).toList();
    final totalSentences = sentences.length;

    // Identify AI-generated sentences based on patterns
    final aiGeneratedSentences = <String>[];
    int aiSentenceCount = 0;

    for (final sentence in sentences) {
      final lowerSentence = sentence.toLowerCase();
      bool isAIGenerated = false;

      // Check for AI patterns in this sentence
      for (final pattern in aiPatterns) {
        if (lowerSentence.contains(pattern)) {
          isAIGenerated = true;
          break;
        }
      }

      // Check for overly formal or technical language
      if (lowerSentence.contains('implementation') ||
          lowerSentence.contains('methodology') ||
          lowerSentence.contains('optimization') ||
          lowerSentence.contains('utilize') ||
          lowerSentence.contains('therefore') ||
          lowerSentence.contains('moreover') ||
          lowerSentence.contains('this is a test') ||
          lowerSentence.contains('wrapped up sprint') ||
          lowerSentence.contains('qa team') ||
          lowerSentence.contains('test coverage') ||
          lowerSentence.contains('defects') ||
          lowerSentence.contains('patch cycle') ||
          lowerSentence.contains('analytics dashboard') ||
          lowerSentence.contains('api gateway') ||
          lowerSentence.contains('board meeting') ||
          lowerSentence.contains('reservation code')) {
        isAIGenerated = true;
      }

      // Special case for "THIS IS A TEST" - highlight it specifically
      if (lowerSentence.contains('this is a test')) {
        aiGeneratedSentences.add('THIS IS A TEST');
        aiSentenceCount++;
      }

      if (isAIGenerated) {
        aiGeneratedSentences.add(sentence.trim());
        aiSentenceCount++;
      }
    }

    return right(TextAnalysisResult(
      source: source,
      aiProbability: aiProbability,
      humanProbability: humanProbability,
      suggestions: suggestions,
      explanation: _getExplanation(source, aiProbability, humanProbability),
      totalSentences: totalSentences,
      aiGeneratedSentences: aiSentenceCount,
      highlightedSentences: aiGeneratedSentences,
    ));
  }

  @override
  Stream<Either<AppError, HumanizationResult>> humanizeText(String text,
      {double? humanLike, double? creativity}) async* {
    // Simulate streaming humanization
    String humanizedText = text;
    double currentHumanLike = 0.0;

    // Step 1: Initial transformation
    humanizedText = humanizedText.replaceAll('artificial intelligence', 'AI');
    currentHumanLike = 0.3;
    yield right(HumanizationResult(
      originalText: text,
      humanizedText: humanizedText,
      humanLike: currentHumanLike,
      changes: ['Replacing technical terms'],
      explanation: 'Starting humanization process...',
    ));
    await Future.delayed(const Duration(milliseconds: 500));

    // Step 2: More transformations
    humanizedText = humanizedText.replaceAll('machine learning', 'ML');
    humanizedText = humanizedText.replaceAll('neural network', 'neural net');
    currentHumanLike = 0.5;
    yield right(HumanizationResult(
      originalText: text,
      humanizedText: humanizedText,
      humanLike: currentHumanLike,
      changes: ['Replacing technical terms', 'Simplifying language'],
      explanation: 'Simplifying technical terminology...',
    ));
    await Future.delayed(const Duration(milliseconds: 500));

    // Step 3: Add conversational elements
    if (!humanizedText.contains('I think') && !humanizedText.contains('I believe')) {
      humanizedText = 'I think ${humanizedText.toLowerCase()}';
    }
    currentHumanLike = 0.7;
    yield right(HumanizationResult(
      originalText: text,
      humanizedText: humanizedText,
      humanLike: currentHumanLike,
      changes: ['Replacing technical terms', 'Simplifying language', 'Adding conversational elements'],
      explanation: 'Adding personal touch...',
    ));
    await Future.delayed(const Duration(milliseconds: 500));

    // Step 4: Make it more casual
    humanizedText = humanizedText.replaceAll('utilize', 'use');
    humanizedText = humanizedText.replaceAll('implement', 'do');
    humanizedText = humanizedText.replaceAll('significant', 'important');
    currentHumanLike = 0.85;

    final changes = [
      'Added conversational elements',
      'Made language more casual',
      'Replaced technical terms with simpler alternatives',
      'Added personal touch with "I think"',
    ];

    yield right(HumanizationResult(
      originalText: text,
      humanizedText: humanizedText,
      humanLike: currentHumanLike,
      changes: changes,
      explanation: 'Text has been humanized by adding personal elements and simplifying technical language.',
    ));
  }

  String _getExplanation(TextSource source, double aiProb, double humanProb) {
    switch (source) {
      case TextSource.ai:
        return 'This text shows characteristics typical of AI-generated content, such as formal language patterns and technical terminology. AI probability: ${(aiProb * 100).toStringAsFixed(1)}%';
      case TextSource.human:
        return 'This text appears to be written by a human, with natural language patterns and personal elements. Human probability: ${(humanProb * 100).toStringAsFixed(1)}%';
      case TextSource.mixed:
        return 'This text shows mixed characteristics of both AI and human writing. Further analysis may be needed to determine the primary source.';
    }
  }
}
