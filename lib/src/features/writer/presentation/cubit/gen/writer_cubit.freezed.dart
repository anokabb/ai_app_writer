// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../writer_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WriterState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WriterStateCopyWith<$Res> {
  factory $WriterStateCopyWith(
          WriterState value, $Res Function(WriterState) then) =
      _$WriterStateCopyWithImpl<$Res, WriterState>;
}

/// @nodoc
class _$WriterStateCopyWithImpl<$Res, $Val extends WriterState>
    implements $WriterStateCopyWith<$Res> {
  _$WriterStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$WriterStateInitialImplCopyWith<$Res> {
  factory _$$WriterStateInitialImplCopyWith(_$WriterStateInitialImpl value,
          $Res Function(_$WriterStateInitialImpl) then) =
      __$$WriterStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WriterStateInitialImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateInitialImpl>
    implements _$$WriterStateInitialImplCopyWith<$Res> {
  __$$WriterStateInitialImplCopyWithImpl(_$WriterStateInitialImpl _value,
      $Res Function(_$WriterStateInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$WriterStateInitialImpl implements WriterStateInitial {
  const _$WriterStateInitialImpl();

  @override
  String toString() {
    return 'WriterState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WriterStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class WriterStateInitial implements WriterState {
  const factory WriterStateInitial() = _$WriterStateInitialImpl;
}

/// @nodoc
abstract class _$$WriterStateAnalyzingImplCopyWith<$Res> {
  factory _$$WriterStateAnalyzingImplCopyWith(_$WriterStateAnalyzingImpl value,
          $Res Function(_$WriterStateAnalyzingImpl) then) =
      __$$WriterStateAnalyzingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WriterStateAnalyzingImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateAnalyzingImpl>
    implements _$$WriterStateAnalyzingImplCopyWith<$Res> {
  __$$WriterStateAnalyzingImplCopyWithImpl(_$WriterStateAnalyzingImpl _value,
      $Res Function(_$WriterStateAnalyzingImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$WriterStateAnalyzingImpl implements WriterStateAnalyzing {
  const _$WriterStateAnalyzingImpl();

  @override
  String toString() {
    return 'WriterState.analyzing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateAnalyzingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return analyzing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return analyzing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (analyzing != null) {
      return analyzing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return analyzing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return analyzing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (analyzing != null) {
      return analyzing(this);
    }
    return orElse();
  }
}

abstract class WriterStateAnalyzing implements WriterState {
  const factory WriterStateAnalyzing() = _$WriterStateAnalyzingImpl;
}

/// @nodoc
abstract class _$$WriterStateAnalysisCompleteImplCopyWith<$Res> {
  factory _$$WriterStateAnalysisCompleteImplCopyWith(
          _$WriterStateAnalysisCompleteImpl value,
          $Res Function(_$WriterStateAnalysisCompleteImpl) then) =
      __$$WriterStateAnalysisCompleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TextAnalysisResult result});

  $TextAnalysisResultCopyWith<$Res> get result;
}

/// @nodoc
class __$$WriterStateAnalysisCompleteImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateAnalysisCompleteImpl>
    implements _$$WriterStateAnalysisCompleteImplCopyWith<$Res> {
  __$$WriterStateAnalysisCompleteImplCopyWithImpl(
      _$WriterStateAnalysisCompleteImpl _value,
      $Res Function(_$WriterStateAnalysisCompleteImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$WriterStateAnalysisCompleteImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as TextAnalysisResult,
    ));
  }

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TextAnalysisResultCopyWith<$Res> get result {
    return $TextAnalysisResultCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$WriterStateAnalysisCompleteImpl implements WriterStateAnalysisComplete {
  const _$WriterStateAnalysisCompleteImpl(this.result);

  @override
  final TextAnalysisResult result;

  @override
  String toString() {
    return 'WriterState.analysisComplete(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateAnalysisCompleteImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriterStateAnalysisCompleteImplCopyWith<_$WriterStateAnalysisCompleteImpl>
      get copyWith => __$$WriterStateAnalysisCompleteImplCopyWithImpl<
          _$WriterStateAnalysisCompleteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return analysisComplete(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return analysisComplete?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (analysisComplete != null) {
      return analysisComplete(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return analysisComplete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return analysisComplete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (analysisComplete != null) {
      return analysisComplete(this);
    }
    return orElse();
  }
}

abstract class WriterStateAnalysisComplete implements WriterState {
  const factory WriterStateAnalysisComplete(final TextAnalysisResult result) =
      _$WriterStateAnalysisCompleteImpl;

  TextAnalysisResult get result;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriterStateAnalysisCompleteImplCopyWith<_$WriterStateAnalysisCompleteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriterStateAnalysisErrorImplCopyWith<$Res> {
  factory _$$WriterStateAnalysisErrorImplCopyWith(
          _$WriterStateAnalysisErrorImpl value,
          $Res Function(_$WriterStateAnalysisErrorImpl) then) =
      __$$WriterStateAnalysisErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AppError error});

  $AppErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$WriterStateAnalysisErrorImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateAnalysisErrorImpl>
    implements _$$WriterStateAnalysisErrorImplCopyWith<$Res> {
  __$$WriterStateAnalysisErrorImplCopyWithImpl(
      _$WriterStateAnalysisErrorImpl _value,
      $Res Function(_$WriterStateAnalysisErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$WriterStateAnalysisErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as AppError,
    ));
  }

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AppErrorCopyWith<$Res> get error {
    return $AppErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$WriterStateAnalysisErrorImpl implements WriterStateAnalysisError {
  const _$WriterStateAnalysisErrorImpl(this.error);

  @override
  final AppError error;

  @override
  String toString() {
    return 'WriterState.analysisError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateAnalysisErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriterStateAnalysisErrorImplCopyWith<_$WriterStateAnalysisErrorImpl>
      get copyWith => __$$WriterStateAnalysisErrorImplCopyWithImpl<
          _$WriterStateAnalysisErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return analysisError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return analysisError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (analysisError != null) {
      return analysisError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return analysisError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return analysisError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (analysisError != null) {
      return analysisError(this);
    }
    return orElse();
  }
}

abstract class WriterStateAnalysisError implements WriterState {
  const factory WriterStateAnalysisError(final AppError error) =
      _$WriterStateAnalysisErrorImpl;

  AppError get error;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriterStateAnalysisErrorImplCopyWith<_$WriterStateAnalysisErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriterStateHumanizingImplCopyWith<$Res> {
  factory _$$WriterStateHumanizingImplCopyWith(
          _$WriterStateHumanizingImpl value,
          $Res Function(_$WriterStateHumanizingImpl) then) =
      __$$WriterStateHumanizingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WriterStateHumanizingImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateHumanizingImpl>
    implements _$$WriterStateHumanizingImplCopyWith<$Res> {
  __$$WriterStateHumanizingImplCopyWithImpl(_$WriterStateHumanizingImpl _value,
      $Res Function(_$WriterStateHumanizingImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$WriterStateHumanizingImpl implements WriterStateHumanizing {
  const _$WriterStateHumanizingImpl();

  @override
  String toString() {
    return 'WriterState.humanizing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateHumanizingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return humanizing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return humanizing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizing != null) {
      return humanizing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return humanizing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return humanizing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizing != null) {
      return humanizing(this);
    }
    return orElse();
  }
}

abstract class WriterStateHumanizing implements WriterState {
  const factory WriterStateHumanizing() = _$WriterStateHumanizingImpl;
}

/// @nodoc
abstract class _$$WriterStateHumanizationProgressImplCopyWith<$Res> {
  factory _$$WriterStateHumanizationProgressImplCopyWith(
          _$WriterStateHumanizationProgressImpl value,
          $Res Function(_$WriterStateHumanizationProgressImpl) then) =
      __$$WriterStateHumanizationProgressImplCopyWithImpl<$Res>;
  @useResult
  $Res call({HumanizationResult result});

  $HumanizationResultCopyWith<$Res> get result;
}

/// @nodoc
class __$$WriterStateHumanizationProgressImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res,
        _$WriterStateHumanizationProgressImpl>
    implements _$$WriterStateHumanizationProgressImplCopyWith<$Res> {
  __$$WriterStateHumanizationProgressImplCopyWithImpl(
      _$WriterStateHumanizationProgressImpl _value,
      $Res Function(_$WriterStateHumanizationProgressImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$WriterStateHumanizationProgressImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as HumanizationResult,
    ));
  }

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HumanizationResultCopyWith<$Res> get result {
    return $HumanizationResultCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$WriterStateHumanizationProgressImpl
    implements WriterStateHumanizationProgress {
  const _$WriterStateHumanizationProgressImpl(this.result);

  @override
  final HumanizationResult result;

  @override
  String toString() {
    return 'WriterState.humanizationProgress(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateHumanizationProgressImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriterStateHumanizationProgressImplCopyWith<
          _$WriterStateHumanizationProgressImpl>
      get copyWith => __$$WriterStateHumanizationProgressImplCopyWithImpl<
          _$WriterStateHumanizationProgressImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return humanizationProgress(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return humanizationProgress?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationProgress != null) {
      return humanizationProgress(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return humanizationProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return humanizationProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationProgress != null) {
      return humanizationProgress(this);
    }
    return orElse();
  }
}

abstract class WriterStateHumanizationProgress implements WriterState {
  const factory WriterStateHumanizationProgress(
      final HumanizationResult result) = _$WriterStateHumanizationProgressImpl;

  HumanizationResult get result;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriterStateHumanizationProgressImplCopyWith<
          _$WriterStateHumanizationProgressImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriterStateHumanizationCompleteImplCopyWith<$Res> {
  factory _$$WriterStateHumanizationCompleteImplCopyWith(
          _$WriterStateHumanizationCompleteImpl value,
          $Res Function(_$WriterStateHumanizationCompleteImpl) then) =
      __$$WriterStateHumanizationCompleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({HumanizationResult result});

  $HumanizationResultCopyWith<$Res> get result;
}

/// @nodoc
class __$$WriterStateHumanizationCompleteImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res,
        _$WriterStateHumanizationCompleteImpl>
    implements _$$WriterStateHumanizationCompleteImplCopyWith<$Res> {
  __$$WriterStateHumanizationCompleteImplCopyWithImpl(
      _$WriterStateHumanizationCompleteImpl _value,
      $Res Function(_$WriterStateHumanizationCompleteImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$WriterStateHumanizationCompleteImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as HumanizationResult,
    ));
  }

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HumanizationResultCopyWith<$Res> get result {
    return $HumanizationResultCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$WriterStateHumanizationCompleteImpl
    implements WriterStateHumanizationComplete {
  const _$WriterStateHumanizationCompleteImpl(this.result);

  @override
  final HumanizationResult result;

  @override
  String toString() {
    return 'WriterState.humanizationComplete(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateHumanizationCompleteImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriterStateHumanizationCompleteImplCopyWith<
          _$WriterStateHumanizationCompleteImpl>
      get copyWith => __$$WriterStateHumanizationCompleteImplCopyWithImpl<
          _$WriterStateHumanizationCompleteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return humanizationComplete(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return humanizationComplete?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationComplete != null) {
      return humanizationComplete(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return humanizationComplete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return humanizationComplete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationComplete != null) {
      return humanizationComplete(this);
    }
    return orElse();
  }
}

abstract class WriterStateHumanizationComplete implements WriterState {
  const factory WriterStateHumanizationComplete(
      final HumanizationResult result) = _$WriterStateHumanizationCompleteImpl;

  HumanizationResult get result;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriterStateHumanizationCompleteImplCopyWith<
          _$WriterStateHumanizationCompleteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriterStateHumanizationErrorImplCopyWith<$Res> {
  factory _$$WriterStateHumanizationErrorImplCopyWith(
          _$WriterStateHumanizationErrorImpl value,
          $Res Function(_$WriterStateHumanizationErrorImpl) then) =
      __$$WriterStateHumanizationErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AppError error});

  $AppErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$WriterStateHumanizationErrorImplCopyWithImpl<$Res>
    extends _$WriterStateCopyWithImpl<$Res, _$WriterStateHumanizationErrorImpl>
    implements _$$WriterStateHumanizationErrorImplCopyWith<$Res> {
  __$$WriterStateHumanizationErrorImplCopyWithImpl(
      _$WriterStateHumanizationErrorImpl _value,
      $Res Function(_$WriterStateHumanizationErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$WriterStateHumanizationErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as AppError,
    ));
  }

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AppErrorCopyWith<$Res> get error {
    return $AppErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$WriterStateHumanizationErrorImpl
    implements WriterStateHumanizationError {
  const _$WriterStateHumanizationErrorImpl(this.error);

  @override
  final AppError error;

  @override
  String toString() {
    return 'WriterState.humanizationError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriterStateHumanizationErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriterStateHumanizationErrorImplCopyWith<
          _$WriterStateHumanizationErrorImpl>
      get copyWith => __$$WriterStateHumanizationErrorImplCopyWithImpl<
          _$WriterStateHumanizationErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() analyzing,
    required TResult Function(TextAnalysisResult result) analysisComplete,
    required TResult Function(AppError error) analysisError,
    required TResult Function() humanizing,
    required TResult Function(HumanizationResult result) humanizationProgress,
    required TResult Function(HumanizationResult result) humanizationComplete,
    required TResult Function(AppError error) humanizationError,
  }) {
    return humanizationError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? analyzing,
    TResult? Function(TextAnalysisResult result)? analysisComplete,
    TResult? Function(AppError error)? analysisError,
    TResult? Function()? humanizing,
    TResult? Function(HumanizationResult result)? humanizationProgress,
    TResult? Function(HumanizationResult result)? humanizationComplete,
    TResult? Function(AppError error)? humanizationError,
  }) {
    return humanizationError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? analyzing,
    TResult Function(TextAnalysisResult result)? analysisComplete,
    TResult Function(AppError error)? analysisError,
    TResult Function()? humanizing,
    TResult Function(HumanizationResult result)? humanizationProgress,
    TResult Function(HumanizationResult result)? humanizationComplete,
    TResult Function(AppError error)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationError != null) {
      return humanizationError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriterStateInitial value) initial,
    required TResult Function(WriterStateAnalyzing value) analyzing,
    required TResult Function(WriterStateAnalysisComplete value)
        analysisComplete,
    required TResult Function(WriterStateAnalysisError value) analysisError,
    required TResult Function(WriterStateHumanizing value) humanizing,
    required TResult Function(WriterStateHumanizationProgress value)
        humanizationProgress,
    required TResult Function(WriterStateHumanizationComplete value)
        humanizationComplete,
    required TResult Function(WriterStateHumanizationError value)
        humanizationError,
  }) {
    return humanizationError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriterStateInitial value)? initial,
    TResult? Function(WriterStateAnalyzing value)? analyzing,
    TResult? Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult? Function(WriterStateAnalysisError value)? analysisError,
    TResult? Function(WriterStateHumanizing value)? humanizing,
    TResult? Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult? Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult? Function(WriterStateHumanizationError value)? humanizationError,
  }) {
    return humanizationError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriterStateInitial value)? initial,
    TResult Function(WriterStateAnalyzing value)? analyzing,
    TResult Function(WriterStateAnalysisComplete value)? analysisComplete,
    TResult Function(WriterStateAnalysisError value)? analysisError,
    TResult Function(WriterStateHumanizing value)? humanizing,
    TResult Function(WriterStateHumanizationProgress value)?
        humanizationProgress,
    TResult Function(WriterStateHumanizationComplete value)?
        humanizationComplete,
    TResult Function(WriterStateHumanizationError value)? humanizationError,
    required TResult orElse(),
  }) {
    if (humanizationError != null) {
      return humanizationError(this);
    }
    return orElse();
  }
}

abstract class WriterStateHumanizationError implements WriterState {
  const factory WriterStateHumanizationError(final AppError error) =
      _$WriterStateHumanizationErrorImpl;

  AppError get error;

  /// Create a copy of WriterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriterStateHumanizationErrorImplCopyWith<
          _$WriterStateHumanizationErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
